<!DOCTYPE html>
<html lang="en">
<head>
<title>Parametric Graphing Utility</title>
<style>
html,body { width: 100%; height: 100%; margin: 0px; overflow: hidden; }
form, input, p, li, #mouse_coords { font-family: consolas, monospace; font-size: 12pt; }
ul { width: 85%; }
#mouse_coords {
	position: fixed;
	top: 20px;
	left: 20px;
	color: blue;
	font-weight: bold;
	white-space: pre;
}

#equations { 
	position: fixed;
	bottom: 20px;
	left: 20px;
	border: 1px solid black;
	background-color: white;
	padding: 10px;
}
input { padding: 5px; margin: 5px auto; }
#equation input { width: 300px; }
#error { position: fixed; top: 5px; right: 40px; color: red; font-size: 14pt; font-weight: bold; }
canvas { margin-left: 5px; margin-top: 5px; }

#help, #settings { 
	position: fixed;
	bottom: 50px;
	right: 30px; 
	margin: 0;
	padding-top: 0px;
	transition: all 0.25s;
}
#settings { right: 150px; z-index: 1; }

.label { 
	padding: 10px 5px;
	border: 1px solid black;
	border-bottom: 1px solid white;
	max-width: 80px;
	text-align: center;
	margin: 0px 20px -1px auto;/*top right bottom left*/
	background-color: white;
	position: relative;
	font-size: 14pt;
}
#settings .label { max-width: 100px; }

#help > div, #settings > div { 
	padding: 5px 0px;
	padding-left: 20px;
	border: 1px solid black;
	max-width: 500px;
	max-height: 300px;
	background-color: white;
	overflow-y: scroll;
}

#settings input { width: 50%; }
#settings #color_r, #settings #color_g, #settings #color_b { width: 35px; }
#settings #spu { width : 25%; }
</style>
<script type="text/javascript" src="parse_equation.js"></script>
<script>
var error;
var graphX, x_val, graphY, y_val;
var equation;
var tUnits = 1000;
var pixelsPerUnit = 20;
var samplesPerUnit = 25;
var unitsPerNotch = 1;
var curveColor = { r: 0, g: 0, b: 0 };

var t_range, ppu, spu, upn, curve_r, curve_g, curve_b;
var mouseCoords;

var canvas, ctx;

function resize() { canvas.width = window.innerWidth - 10; canvas.height = window.innerHeight - 10; }

function graphSetup() {
	canvas = document.querySelector("canvas");
	ctx = canvas.getContext('2d');
	resize();

	error = document.querySelector('#error');
	
	graphX = document.querySelector("#x_eq");
	graphY = document.querySelector("#y_eq");
	graphX.onchange = updateEquation;
	graphY.onchange = updateEquation;
	
	t_range = document.querySelector('#t_range');
	spu = document.querySelector('#spu');
	ppu = document.querySelector('#ppu');
	upn = document.querySelector('#upn');
	color_r = document.querySelector('#color_r');
	color_g = document.querySelector('#color_g');
	color_b = document.querySelector('#color_b');
	
	function tryParse(str) {
		var val = Number.parseFloat(str);
		if(Number.isNaN(val)) { val = undefined; errString = 'Invalid setting'; }
		updateError(val);
		return val;
	};
	
	t_range.value = tUnits;
	t_range.onchange = function() { var val = tryParse(this.value); tUnits = (val != undefined && val) || tUnits; graphDraw(); };
	spu.value = samplesPerUnit;
	spu.onchange = function() { var val = tryParse(this.value); samplesPerUnit = (val != undefined && val) || samplesPerUnit; graphDraw(); };
	ppu.value = pixelsPerUnit;
	ppu.onchange = function() { var val = tryParse(this.value); pixelsPerUnit = (val != undefined && val) || pixelsPerUnit; graphDraw(); };
	upn.value = unitsPerNotch;
	upn.onchange = function() { var val = tryParse(this.value); unitsPerNotch = (val != undefined && val) || unitsPerNotch; graphDraw(); };
	color_r.value = curveColor.r;
	color_r.onchange = function() { var val = tryParse(this.value); if (val != undefined) curveColor.r = val | 0; graphDraw(); };
	color_g.value = curveColor.g;
	color_g.onchange = function() { var val = tryParse(this.value); if (val != undefined) curveColor.g = val | 0; graphDraw(); };
	color_b.value = curveColor.b;
	color_b.onchange = function() { var val = tryParse(this.value); if (val != undefined) curveColor.b = val | 0; graphDraw(); };
	
	equation = {};
	updateEquation();
}

function updateError(val) {
	if(val == undefined) error.innerHTML = 'ERROR: ' + errString;
	else 	 error.innerHTML = '';
}

function parseEquations(x_eq, y_eq) {
	if(x_val != x_eq) {
		x_val = x_eq;
		equation.x = parseEquation(x_eq);
		updateError(equation.x);
		if(!equation.x)	return;
	}
	if(y_val != y_eq) {
		y_val = y_eq;
		equation.y = parseEquation(y_eq);
		updateError(equation.y);
		if(!equation.y) return;
	}
} 

function updateEquation() { 
	parseEquations(graphX.value, graphY.value); 
	graphDraw();
}

function drawT(t,tn) {
	var tx = equation.x.evaluate(t) * pixelsPerUnit
	  , ty = equation.y.evaluate(t) * pixelsPerUnit;
	if(Number.isNaN(tx) || Number.isNaN(ty) || 
		abs(tx) > canvas.width / 2 || abs(ty) > canvas.height / 2)
		return;
	var bigNum = Number.MAX_VALUE;
	!Number.isFinite(tx) && (tx = Math.sign(tx) * canvas.width/2);
	!Number.isFinite(ty) && (ty = Math.sign(ty) * canvas.height/2);
	
	var txn = equation.x.evaluate(tn) * pixelsPerUnit
	  , tyn = equation.y.evaluate(tn) * pixelsPerUnit;
	(Number.isNaN(txn) && (txn = tx)) || 
	(!Number.isFinite(txn) && (txn = Math.sign(txn) * canvas.width/2));
	(Number.isNaN(tyn) && (tyn = ty)) || 
	(!Number.isFinite(tyn) && (tyn = Math.sign(tyn) * canvas.height/2));
	
	//console.log('(' + tx + ', ' + ty + '), (' + txn + ', ' + tyn + ')');
	ctx.moveTo(tx, -ty);
	ctx.lineTo(txn,-tyn);
}

function graphDraw() {
	ctx.clearRect(0,0,canvas.width,canvas.height);
	ctx.beginPath();
	ctx.moveTo(0, canvas.height / 2);
	ctx.lineTo(canvas.width, canvas.height / 2);
	ctx.stroke();
	ctx.moveTo(canvas.width / 2, 0);
	ctx.lineTo(canvas.width / 2, canvas.height);
	ctx.stroke();
	
	ctx.save();
	ctx.strokeStyle = 'rgb(' + curveColor.r + ',' + curveColor.g + ',' + curveColor.b + ')';
	ctx.translate(canvas.width/2,canvas.height/2);
	
	for(var notches = canvas.width / pixelsPerUnit / unitsPerNotch, i = 0; i < notches; i++) {
		var pos = canvas.width * i / notches;
		ctx.moveTo(pos,-5); ctx.lineTo(pos,5); ctx.stroke();
		ctx.moveTo(-pos,-5); ctx.lineTo(-pos,5); ctx.stroke();
	}
	for(var notches = canvas.height / pixelsPerUnit / unitsPerNotch, i = 0; i < notches; i++) {
		var pos = canvas.height * i / notches;
		ctx.moveTo(-5,pos); ctx.lineTo(5,pos); ctx.stroke();
		ctx.moveTo(-5,-pos); ctx.lineTo(5,-pos); ctx.stroke();
	}
	if(equation.x && equation.y) {
		var tUpS = 1 / samplesPerUnit;
		for(var t = 0.000001, end = tUnits - tUpS; t < end; t += tUpS) {
			drawT(t,(t+tUpS));
		}
		ctx.stroke();
		for(var t = 0.000001, end = tUnits - tUpS; t < end; t += tUpS) {
			drawT(-t,-(t+tUpS));
		}
		ctx.stroke();
	}	
	ctx.restore();
}

window.onload = function() { 
	var boxes = [ 
		  { box: document.querySelector('#settings') } 
		, { box: document.querySelector('#help') }
	];
	for(var i = 0; i < boxes.length; i++) (function(i) {
		boxes[i].label = boxes[i].box.querySelector('.label');
		boxes[i].vertDisp = boxes[i].label.offsetHeight - boxes[i].box.offsetHeight - 1 + 'px';
		boxes[i].label.onclick = function(e) { e && e.stopPropagation(); (function(i) {
			if(boxes[i].box.style.bottom == boxes[i].vertDisp) { boxes[i].box.style.bottom = '50px'; }
			else { boxes[i].box.style.bottom = boxes[i].vertDisp; }
			boxes.forEach(function(el,j) { i != j && (boxes[j].box.style.bottom = el.vertDisp); });
		})(i); };
	})(i);
	boxes.forEach(function(el,i) { boxes[i].label.onclick(); });
	boxes[boxes.length-1].label.onclick();
	graphSetup();
	canvas.onclick = function() { 
		boxes.forEach(function(el,j) { boxes[j].box.style.bottom = el.vertDisp; }); 
	};
	
	mouseCoords = document.querySelector('#mouse_coords');
}

window.onresize = function() { resize(); graphDraw(); };
window.onmousemove = function(e) { 
	var mouseX =  (e.pageX - window.innerWidth  / 2) / pixelsPerUnit
	  , mouseY = -(e.pageY - window.innerHeight / 2) / pixelsPerUnit;
	mouseCoords.innerHTML = ((mouseX > 0) ? ' ' : '') + mouseX.toFixed(3) + ', ' 
						  + ((mouseY > 0) ? ' ' : '') + mouseY.toFixed(3); 
}
</script>

</head>
<body>
<canvas></canvas>
<div id="mouse_coords"></div>
<form id="equations">
X(t) = <input type="text" id="x_eq" value="5(3.1cost-cos(3.1t))"><br>
Y(t) = <input type="text" id="y_eq" value="5(3.1sint-sin(3.1t))">
</form>
<div id="settings">
	<p class="label">Settings</p>
	<div>
	<form>
	<p><em>t</em>-range: &#177; <input type="text" id="t_range"></p>
	<p>Samples per Unit: <input type="text" id="spu"></p>
	<p>Pixels per Unit: <input type="text" id="ppu"></p>
	<p>Units per Notch: <input type="text" id="upn"></p>
	<p>Curve Color: </p>
	<p>
		R: <input type="text" id="color_r">
		G: <input type="text" id="color_g">
		B: <input type="text" id="color_b">
	</p>
	</form>
	</div>
</div>
<div id="help">
	<p class="label">Help</p>
	<div>
	<p><b>Equation Info</b></p>
	<p>
		Enter any parametric equation you'd like into the boxes on the left; 
		hit enter or click outside the box to update the equation. 
		If there is an issue with the equation you entered, 
		an error message will appear on the top right of the page. 
		You can cycle through old inputs with Ctrl+Z, and go back to newer ones with Ctrl+Y.
	</p>
	<p>
		All numbers and the constants pi, phi, and e are accepted. 
		The basic operations of ^, *, /, +, and - are recognized, as well as 
		(), | | (absolute value), sqrt, 
		all standard, inverse, and hyperbolic trig functions, ln, and log.
	</p>
	<p>
		When raising a base to a negative power, wrap the exponent in parentheses. 
		As normal, do the same when raising a negative base to any power.
	</p>
	<p>
		log is written as log_[base][value]. (omit the brackets) 
		If no base is specified, base 10 is assumed.
	</p>
	<p>
		Trig functions support the traditional exponent syntax of [trig]^[exp][value]. 
		However, the syntax [trig]^(-1)[value] for the inverse version of the trig function 
		is not supported; you'll only get 1/[trig][value]. Instead, use a[trig] or arc[trig].
	</p>
	<p><b>Other Info</b></p>
	<p>The numbers in the top left corner are the grid-coordinates of your mouse.</p>
	<p>
		In the settings menu, you can change 
		<b>t-range</b>, which is the values sampled when drawing the curve, 
		<b>samples per unit</b>, which determines the value (1 / SPU) t is incrmented by, 
		<b>pixels per unit</b>, which is exactly what it sounds like, 
		<b>units per notch</b>, which controls the number of units each notch on the axes represents, 
		and <b>curve color</b>, which changes the color of the graph.
	</p>
	<p><b>Future</b></p>
	<p>
		The JS Math.pow function does not accept negative bases for fractional exponents 
		(aka roots) and you won't be able to see the graph in areas that this applies. 
		I may replace this function with one of my own later to fix this.
	<p>
	<p>
		Functions with asymptotes that approach the opposite sign of infinity on each side 
		will not draw correctly; a prominent example is (t, tan(t)). 
		I'm not sure how to fix this in a way that doesn't mess up other equations, 
		so I'm leaving it alone. I may implement an asymptote solver to help.
	</p>
	<p>
		There is a minor parser bug where negative numbers as the second argument of *, /, or ^ 
		or arguments to a function will be evaluated as fn(0)-n instead of fn(-n). 
		(*0, /0, and ^0 for the operators) 
		This can be avoided by wrapping the value in (), but the error is hard to differentiate 
		from a standard () error. 
		This is the last major parser bug, but I don't know if it will be fixed.
	</p>
	<p>I'd like to add the following features at some point in time:</p>
	<ul>
		<li>Variables connected to sliders for easy tweaks and experimentation</li>
		<li>Asymptote visualization</li>
		<li>Click on the graph, get the values for the nearest point on the curve</li>
		<li>Polar and Cartesian equation support (long term)</li>
		<li>3D graphs (very long term)</li>
	</ul>
	<p><b>Cool parametric curves:</b></p>
	<p><em>Astroid:</em> x(t) = acos^3t, y(t) = asin^3t</p>
	<p><em>Epicycloid:</em></p>
	<p>x(t) = r((k+1)cost - cos((k+1)t)), </p>
	<p>y(t) = r((k+1)sint - sin((k+1)t))</p>
	<p>Values of interest: k = 1 (cardioid), 2.1
	<p><a href="https://elepa.files.wordpress.com/2013/11/fifty-famous-curves.pdf">https://elepa.files.wordpress.com/2013/11/fifty-famous-curves.pdf</a></p>
	</div>
</div>
<p id="error"></p>
</body>
</html>